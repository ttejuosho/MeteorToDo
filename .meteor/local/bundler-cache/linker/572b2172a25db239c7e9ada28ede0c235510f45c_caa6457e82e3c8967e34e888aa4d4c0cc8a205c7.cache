[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar EJSON = Package.ejson.EJSON;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\nvar Symbol = Package['ecmascript-runtime-client'].Symbol;\nvar Map = Package['ecmascript-runtime-client'].Map;\nvar Set = Package['ecmascript-runtime-client'].Set;\n\n/* Package-scope variables */\nvar check, Match;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"check\":{\"match.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/check/match.js                                                                                            //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nmodule.export({\n  check: function () {\n    return check;\n  },\n  Match: function () {\n    return Match;\n  }\n});\n// XXX docs\n// Things we explicitly do NOT support:\n//    - heterogenous arrays\nvar currentArgumentChecker = new Meteor.EnvironmentVariable();\n\nvar isPlainObject = require(\"./isPlainObject.js\").isPlainObject;\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n/**\n * @summary Check that a value matches a [pattern](#matchpatterns).\n * If the value does not match the pattern, throw a `Match.Error`.\n *\n * Particularly useful to assert that arguments to a function have the right\n * types and structure.\n * @locus Anywhere\n * @param {Any} value The value to check\n * @param {MatchPattern} pattern The pattern to match\n * `value` against\n */\n\nvar check = function (value, pattern) {\n  // Record that check got called, if somebody cared.\n  //\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\n  // from non-Fiber server contexts; the downside is that if you forget to\n  // bindEnvironment on some random callback in your method/publisher,\n  // it might not find the argumentChecker and you'll get an error about\n  // not checking an argument that it looks like you're checking (instead\n  // of just getting a \"Node code must run in a Fiber\" error).\n  var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\n  if (argChecker) argChecker.checking(value);\n  var result = testSubtree(value, pattern);\n\n  if (result) {\n    var err = new Match.Error(result.message);\n\n    if (result.path) {\n      err.message += \" in field \" + result.path;\n      err.path = result.path;\n    }\n\n    throw err;\n  }\n};\n\nvar Match = {\n  Optional: function (pattern) {\n    return new Optional(pattern);\n  },\n  Maybe: function (pattern) {\n    return new Maybe(pattern);\n  },\n  OneOf: function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new OneOf(args);\n  },\n  Any: ['__any__'],\n  Where: function (condition) {\n    return new Where(condition);\n  },\n  ObjectIncluding: function (pattern) {\n    return new ObjectIncluding(pattern);\n  },\n  ObjectWithValues: function (pattern) {\n    return new ObjectWithValues(pattern);\n  },\n  // Matches only signed 32-bit integers\n  Integer: ['__integer__'],\n  // XXX matchers should know how to describe themselves for errors\n  Error: Meteor.makeErrorType(\"Match.Error\", function (msg) {\n    this.message = \"Match error: \" + msg; // The path of the value that failed to match. Initially empty, this gets\n    // populated by catching and rethrowing the exception as it goes back up the\n    // stack.\n    // E.g.: \"vals[3].entity.created\"\n\n    this.path = \"\"; // If this gets sent over DDP, don't give full internal details but at least\n    // provide something better than 500 Internal server error.\n\n    this.sanitizedError = new Meteor.Error(400, \"Match failed\");\n  }),\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\n  // or false (unless an error other than Match.Error was thrown). It does not\n  // interact with _failIfArgumentsAreNotAllChecked.\n  // XXX maybe also implement a Match.match which returns more information about\n  //     failures but without using exception handling or doing what check()\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\n\n  /**\n   * @summary Returns true if the value matches the pattern.\n   * @locus Anywhere\n   * @param {Any} value The value to check\n   * @param {MatchPattern} pattern The pattern to match `value` against\n   */\n  test: function (value, pattern) {\n    return !testSubtree(value, pattern);\n  },\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\n  // `args` (either directly or in the first level of an array), throws an error\n  // (using `description` in the message).\n  //\n  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {\n    var argChecker = new ArgumentChecker(args, description);\n    var result = currentArgumentChecker.withValue(argChecker, function () {\n      return f.apply(context, args);\n    }); // If f didn't itself throw, make sure it checked all of its arguments.\n\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\n    return result;\n  }\n};\n\nvar Optional = function () {\n  function Optional(pattern) {\n    this.pattern = pattern;\n  }\n\n  return Optional;\n}();\n\nvar Maybe = function () {\n  function Maybe(pattern) {\n    this.pattern = pattern;\n  }\n\n  return Maybe;\n}();\n\nvar OneOf = function () {\n  function OneOf(choices) {\n    if (!choices || choices.length === 0) throw new Error(\"Must provide at least one choice to Match.OneOf\");\n    this.choices = choices;\n  }\n\n  return OneOf;\n}();\n\nvar Where = function () {\n  function Where(condition) {\n    this.condition = condition;\n  }\n\n  return Where;\n}();\n\nvar ObjectIncluding = function () {\n  function ObjectIncluding(pattern) {\n    this.pattern = pattern;\n  }\n\n  return ObjectIncluding;\n}();\n\nvar ObjectWithValues = function () {\n  function ObjectWithValues(pattern) {\n    this.pattern = pattern;\n  }\n\n  return ObjectWithValues;\n}();\n\nvar stringForErrorMessage = function (value, options) {\n  options = options || {};\n  if (value === null) return \"null\";\n\n  if (options.onlyShowType) {\n    return _typeof(value);\n  } // Your average non-object things.  Saves from doing the try/catch below for.\n\n\n  if (_typeof(value) !== \"object\") {\n    return EJSON.stringify(value);\n  }\n\n  try {\n    // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\n    // If the native stringify is going to choke, EJSON.stringify is going to choke too.\n    JSON.stringify(value);\n  } catch (stringifyError) {\n    if (stringifyError.name === \"TypeError\") {\n      return _typeof(value);\n    }\n  }\n\n  return EJSON.stringify(value);\n};\n\nvar typeofChecks = [[String, \"string\"], [Number, \"number\"], [Boolean, \"boolean\"], // While we don't allow undefined/function in EJSON, this is good for optional\n// arguments with OneOf.\n[Function, \"function\"], [undefined, \"undefined\"]]; // Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.\n\nvar testSubtree = function (value, pattern) {\n  // Match anything!\n  if (pattern === Match.Any) return false; // Basic atomic types.\n  // Do not match boxed objects (e.g. String, Boolean)\n\n  for (var i = 0; i < typeofChecks.length; ++i) {\n    if (pattern === typeofChecks[i][0]) {\n      if (_typeof(value) === typeofChecks[i][1]) return false;\n      return {\n        message: \"Expected \" + typeofChecks[i][1] + \", got \" + stringForErrorMessage(value, {\n          onlyShowType: true\n        }),\n        path: \"\"\n      };\n    }\n  }\n\n  if (pattern === null) {\n    if (value === null) {\n      return false;\n    }\n\n    return {\n      message: \"Expected null, got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  } // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\n\n\n  if (typeof pattern === \"string\" || typeof pattern === \"number\" || typeof pattern === \"boolean\") {\n    if (value === pattern) return false;\n    return {\n      message: \"Expected \" + pattern + \", got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  } // Match.Integer is special type encoded with array\n\n\n  if (pattern === Match.Integer) {\n    // There is no consistent and reliable way to check if variable is a 64-bit\n    // integer. One of the popular solutions is to get reminder of division by 1\n    // but this method fails on really large floats with big precision.\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\n    // Bitwise operators work consistantly but always cast variable to 32-bit\n    // signed integer according to JavaScript specs.\n    if (typeof value === \"number\" && (value | 0) === value) return false;\n    return {\n      message: \"Expected Integer, got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  } // \"Object\" is shorthand for Match.ObjectIncluding({});\n\n\n  if (pattern === Object) pattern = Match.ObjectIncluding({}); // Array (checked AFTER Any, which is implemented as an Array).\n\n  if (pattern instanceof Array) {\n    if (pattern.length !== 1) {\n      return {\n        message: \"Bad pattern: arrays must have one type element\" + stringForErrorMessage(pattern),\n        path: \"\"\n      };\n    }\n\n    if (!Array.isArray(value) && !isArguments(value)) {\n      return {\n        message: \"Expected array, got \" + stringForErrorMessage(value),\n        path: \"\"\n      };\n    }\n\n    for (var i = 0, length = value.length; i < length; i++) {\n      var result = testSubtree(value[i], pattern[0]);\n\n      if (result) {\n        result.path = _prependPath(i, result.path);\n        return result;\n      }\n    }\n\n    return false;\n  } // Arbitrary validation checks. The condition can return false or throw a\n  // Match.Error (ie, it can internally use check()) to fail.\n\n\n  if (pattern instanceof Where) {\n    var result;\n\n    try {\n      result = pattern.condition(value);\n    } catch (err) {\n      if (!(err instanceof Match.Error)) throw err;\n      return {\n        message: err.message,\n        path: err.path\n      };\n    }\n\n    if (result) return false; // XXX this error is terrible\n\n    return {\n      message: \"Failed Match.Where validation\",\n      path: \"\"\n    };\n  }\n\n  if (pattern instanceof Maybe) {\n    pattern = Match.OneOf(undefined, null, pattern.pattern);\n  } else if (pattern instanceof Optional) {\n    pattern = Match.OneOf(undefined, pattern.pattern);\n  }\n\n  if (pattern instanceof OneOf) {\n    for (var i = 0; i < pattern.choices.length; ++i) {\n      var result = testSubtree(value, pattern.choices[i]);\n\n      if (!result) {\n        // No error? Yay, return.\n        return false;\n      } // Match errors just mean try another choice.\n\n    } // XXX this error is terrible\n\n\n    return {\n      message: \"Failed Match.OneOf, Match.Maybe or Match.Optional validation\",\n      path: \"\"\n    };\n  } // A function that isn't something we special-case is assumed to be a\n  // constructor.\n\n\n  if (pattern instanceof Function) {\n    if (value instanceof pattern) return false;\n    return {\n      message: \"Expected \" + (pattern.name || \"particular constructor\"),\n      path: \"\"\n    };\n  }\n\n  var unknownKeysAllowed = false;\n  var unknownKeyPattern;\n\n  if (pattern instanceof ObjectIncluding) {\n    unknownKeysAllowed = true;\n    pattern = pattern.pattern;\n  }\n\n  if (pattern instanceof ObjectWithValues) {\n    unknownKeysAllowed = true;\n    unknownKeyPattern = [pattern.pattern];\n    pattern = {}; // no required keys\n  }\n\n  if (_typeof(pattern) !== \"object\") {\n    return {\n      message: \"Bad pattern: unknown pattern type\",\n      path: \"\"\n    };\n  } // An object, with required and optional keys. Note that this does NOT do\n  // structural matches against objects of special types that happen to match\n  // the pattern: this really needs to be a plain old {Object}!\n\n\n  if (_typeof(value) !== 'object') {\n    return {\n      message: \"Expected object, got \" + _typeof(value),\n      path: \"\"\n    };\n  }\n\n  if (value === null) {\n    return {\n      message: \"Expected object, got null\",\n      path: \"\"\n    };\n  }\n\n  if (!isPlainObject(value)) {\n    return {\n      message: \"Expected plain object\",\n      path: \"\"\n    };\n  }\n\n  var requiredPatterns = {};\n  var optionalPatterns = {};\n  Object.keys(pattern).forEach(function (key) {\n    var subPattern = pattern[key];\n\n    if (subPattern instanceof Optional || subPattern instanceof Maybe) {\n      optionalPatterns[key] = subPattern.pattern;\n    } else {\n      requiredPatterns[key] = subPattern;\n    }\n  });\n\n  for (var key in meteorBabelHelpers.sanitizeForInObject(Object(value))) {\n    var subValue = value[key];\n\n    if (hasOwn.call(requiredPatterns, key)) {\n      var result = testSubtree(subValue, requiredPatterns[key]);\n\n      if (result) {\n        result.path = _prependPath(key, result.path);\n        return result;\n      }\n\n      delete requiredPatterns[key];\n    } else if (hasOwn.call(optionalPatterns, key)) {\n      var result = testSubtree(subValue, optionalPatterns[key]);\n\n      if (result) {\n        result.path = _prependPath(key, result.path);\n        return result;\n      }\n    } else {\n      if (!unknownKeysAllowed) {\n        return {\n          message: \"Unknown key\",\n          path: key\n        };\n      }\n\n      if (unknownKeyPattern) {\n        var result = testSubtree(subValue, unknownKeyPattern[0]);\n\n        if (result) {\n          result.path = _prependPath(key, result.path);\n          return result;\n        }\n      }\n    }\n  }\n\n  var keys = Object.keys(requiredPatterns);\n\n  if (keys.length) {\n    return {\n      message: \"Missing key '\" + keys[0] + \"'\",\n      path: \"\"\n    };\n  }\n};\n\nvar ArgumentChecker =\n/*#__PURE__*/\nfunction () {\n  function ArgumentChecker(args, description) {\n    // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\n    // against its contents.)\n    this.args = _toConsumableArray(args); // Since the common case will be to check arguments in order, and we splice\n    // out arguments when we check them, make it so we splice out from the end\n    // rather than the beginning.\n\n    this.args.reverse();\n    this.description = description;\n  }\n\n  var _proto = ArgumentChecker.prototype;\n\n  _proto.checking = function () {\n    function checking(value) {\n      if (this._checkingOneValue(value)) return; // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\n      // or check([foo, bar], [String]) to count... but only if value wasn't\n      // itself an argument.\n\n      if (Array.isArray(value) || isArguments(value)) {\n        Array.prototype.forEach.call(value, this._checkingOneValue.bind(this));\n      }\n    }\n\n    return checking;\n  }();\n\n  _proto._checkingOneValue = function () {\n    function _checkingOneValue(value) {\n      for (var i = 0; i < this.args.length; ++i) {\n        // Is this value one of the arguments? (This can have a false positive if\n        // the argument is an interned primitive, but it's still a good enough\n        // check.)\n        // (NaN is not === to itself, so we have to check specially.)\n        if (value === this.args[i] || Number.isNaN(value) && Number.isNaN(this.args[i])) {\n          this.args.splice(i, 1);\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    return _checkingOneValue;\n  }();\n\n  _proto.throwUnlessAllArgumentsHaveBeenChecked = function () {\n    function throwUnlessAllArgumentsHaveBeenChecked() {\n      if (this.args.length > 0) throw new Error(\"Did not check() all arguments during \" + this.description);\n    }\n\n    return throwUnlessAllArgumentsHaveBeenChecked;\n  }();\n\n  return ArgumentChecker;\n}();\n\nvar _jsKeywords = [\"do\", \"if\", \"in\", \"for\", \"let\", \"new\", \"try\", \"var\", \"case\", \"else\", \"enum\", \"eval\", \"false\", \"null\", \"this\", \"true\", \"void\", \"with\", \"break\", \"catch\", \"class\", \"const\", \"super\", \"throw\", \"while\", \"yield\", \"delete\", \"export\", \"import\", \"public\", \"return\", \"static\", \"switch\", \"typeof\", \"default\", \"extends\", \"finally\", \"package\", \"private\", \"continue\", \"debugger\", \"function\", \"arguments\", \"interface\", \"protected\", \"implements\", \"instanceof\"]; // Assumes the base of path is already escaped properly\n// returns key + base\n\nfunction _prependPath(key, base) {\n  if (typeof key === \"number\" || key.match(/^[0-9]+$/)) {\n    key = \"[\" + key + \"]\";\n  } else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _jsKeywords.indexOf(key) >= 0) {\n    key = JSON.stringify([key]);\n  }\n\n  if (base && base[0] !== \"[\") {\n    return key + '.' + base;\n  }\n\n  return key + base;\n}\n\nfunction isObject(value) {\n  return _typeof(value) === \"object\" && value !== null;\n}\n\nfunction baseIsArguments(item) {\n  return isObject(item) && Object.prototype.toString.call(item) === '[object Arguments]';\n}\n\nvar isArguments = baseIsArguments(function () {\n  return arguments;\n}()) ? baseIsArguments : function (value) {\n  return isObject(value) && typeof value.callee === \"function\";\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"isPlainObject.js\":function(require,exports){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/check/isPlainObject.js                                                                                    //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n// Copy of jQuery.isPlainObject for the server side from jQuery v3.1.1.\nvar class2type = {};\nvar toString = class2type.toString;\nvar hasOwn = class2type.hasOwnProperty;\nvar fnToString = hasOwn.toString;\nvar ObjectFunctionString = fnToString.call(Object);\nvar getProto = Object.getPrototypeOf;\n\nexports.isPlainObject = function (obj) {\n  var proto, Ctor; // Detect obvious negatives\n  // Use toString instead of jQuery.type to catch host objects\n\n  if (!obj || toString.call(obj) !== \"[object Object]\") {\n    return false;\n  }\n\n  proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain\n\n  if (!proto) {\n    return true;\n  } // Objects with prototype are plain iff they were constructed by a global Object function\n\n\n  Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nvar exports = require(\"/node_modules/meteor/check/match.js\");\n\n/* Exports */\nPackage._define(\"check\", exports, {\n  check: check,\n  Match: Match\n});\n\n})();\n","servePath":"/packages/check.js","sourceMap":{"version":3,"sources":["packages/check/match.js","packages/check/isPlainObject.js"],"names":["module","export","check","Match","currentArgumentChecker","Meteor","EnvironmentVariable","isPlainObject","require","hasOwn","Object","prototype","hasOwnProperty","value","pattern","argChecker","getOrNullIfOutsideFiber","checking","result","testSubtree","err","Error","message","path","Optional","Maybe","OneOf","args","Any","Where","condition","ObjectIncluding","ObjectWithValues","Integer","makeErrorType","msg","sanitizedError","test","_failIfArgumentsAreNotAllChecked","f","context","description","ArgumentChecker","withValue","apply","throwUnlessAllArgumentsHaveBeenChecked","choices","length","stringForErrorMessage","options","onlyShowType","EJSON","stringify","JSON","stringifyError","name","typeofChecks","String","Number","Boolean","Function","undefined","i","Array","isArray","isArguments","_prependPath","unknownKeysAllowed","unknownKeyPattern","requiredPatterns","optionalPatterns","keys","forEach","subPattern","key","subValue","call","reverse","_checkingOneValue","bind","isNaN","splice","_jsKeywords","base","match","indexOf","isObject","baseIsArguments","item","toString","arguments","callee","class2type","fnToString","ObjectFunctionString","getProto","getPrototypeOf","exports","obj","proto","Ctor","constructor"],"mappings":"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","file":"/packages/check.js","sourcesContent":["// XXX docs\n\n// Things we explicitly do NOT support:\n//    - heterogenous arrays\n\nvar currentArgumentChecker = new Meteor.EnvironmentVariable;\nvar isPlainObject = require(\"./isPlainObject.js\").isPlainObject;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n/**\n * @summary Check that a value matches a [pattern](#matchpatterns).\n * If the value does not match the pattern, throw a `Match.Error`.\n *\n * Particularly useful to assert that arguments to a function have the right\n * types and structure.\n * @locus Anywhere\n * @param {Any} value The value to check\n * @param {MatchPattern} pattern The pattern to match\n * `value` against\n */\nexport const check = function (value, pattern) {\n  // Record that check got called, if somebody cared.\n  //\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\n  // from non-Fiber server contexts; the downside is that if you forget to\n  // bindEnvironment on some random callback in your method/publisher,\n  // it might not find the argumentChecker and you'll get an error about\n  // not checking an argument that it looks like you're checking (instead\n  // of just getting a \"Node code must run in a Fiber\" error).\n  var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\n  if (argChecker)\n    argChecker.checking(value);\n  var result = testSubtree(value, pattern);\n  if (result) {\n    var err = new Match.Error(result.message);\n    if (result.path) {\n      err.message += \" in field \" + result.path;\n      err.path = result.path;\n    }\n    throw err;\n  }\n};\n\n/**\n * @namespace Match\n * @summary The namespace for all Match types and methods.\n */\nexport const Match = {\n  Optional: function (pattern) {\n    return new Optional(pattern);\n  },\n  Maybe: function (pattern) {\n    return new Maybe(pattern);\n  },\n  OneOf: function (...args) {\n    return new OneOf(args);\n  },\n  Any: ['__any__'],\n  Where: function (condition) {\n    return new Where(condition);\n  },\n  ObjectIncluding: function (pattern) {\n    return new ObjectIncluding(pattern);\n  },\n  ObjectWithValues: function (pattern) {\n    return new ObjectWithValues(pattern);\n  },\n  // Matches only signed 32-bit integers\n  Integer: ['__integer__'],\n\n  // XXX matchers should know how to describe themselves for errors\n  Error: Meteor.makeErrorType(\"Match.Error\", function (msg) {\n    this.message = \"Match error: \" + msg;\n    // The path of the value that failed to match. Initially empty, this gets\n    // populated by catching and rethrowing the exception as it goes back up the\n    // stack.\n    // E.g.: \"vals[3].entity.created\"\n    this.path = \"\";\n    // If this gets sent over DDP, don't give full internal details but at least\n    // provide something better than 500 Internal server error.\n    this.sanitizedError = new Meteor.Error(400, \"Match failed\");\n  }),\n\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\n  // or false (unless an error other than Match.Error was thrown). It does not\n  // interact with _failIfArgumentsAreNotAllChecked.\n  // XXX maybe also implement a Match.match which returns more information about\n  //     failures but without using exception handling or doing what check()\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\n\n  /**\n   * @summary Returns true if the value matches the pattern.\n   * @locus Anywhere\n   * @param {Any} value The value to check\n   * @param {MatchPattern} pattern The pattern to match `value` against\n   */\n  test(value, pattern) {\n    return !testSubtree(value, pattern);\n  },\n\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\n  // `args` (either directly or in the first level of an array), throws an error\n  // (using `description` in the message).\n  //\n  _failIfArgumentsAreNotAllChecked(f, context, args, description) {\n    var argChecker = new ArgumentChecker(args, description);\n    var result = currentArgumentChecker.withValue(argChecker, function () {\n      return f.apply(context, args);\n    });\n    // If f didn't itself throw, make sure it checked all of its arguments.\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\n    return result;\n  }\n};\n\nclass Optional {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nclass Maybe {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nclass OneOf {\n  constructor(choices) {\n    if (!choices || choices.length === 0)\n      throw new Error(\"Must provide at least one choice to Match.OneOf\");\n    this.choices = choices;\n  }\n}\n\nclass Where {\n  constructor(condition) {\n    this.condition = condition;\n  }\n}\n\nclass ObjectIncluding {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nclass ObjectWithValues {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nvar stringForErrorMessage = function (value, options) {\n  options = options || {};\n\n  if ( value === null ) return \"null\";\n\n  if ( options.onlyShowType ) {\n    return typeof value;\n  }\n\n  // Your average non-object things.  Saves from doing the try/catch below for.\n  if ( typeof value !== \"object\" ) {\n    return EJSON.stringify(value)\n  }\n\n  try {\n    // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\n    // If the native stringify is going to choke, EJSON.stringify is going to choke too.\n    JSON.stringify(value);\n  } catch (stringifyError) {\n    if ( stringifyError.name === \"TypeError\" ) {\n      return typeof value;\n    }\n  }\n\n  return EJSON.stringify(value);\n};\n\nvar typeofChecks = [\n  [String, \"string\"],\n  [Number, \"number\"],\n  [Boolean, \"boolean\"],\n  // While we don't allow undefined/function in EJSON, this is good for optional\n  // arguments with OneOf.\n  [Function, \"function\"],\n  [undefined, \"undefined\"]\n];\n\n// Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.\nvar testSubtree = function (value, pattern) {\n  // Match anything!\n  if (pattern === Match.Any)\n    return false;\n\n  // Basic atomic types.\n  // Do not match boxed objects (e.g. String, Boolean)\n  for (var i = 0; i < typeofChecks.length; ++i) {\n    if (pattern === typeofChecks[i][0]) {\n      if (typeof value === typeofChecks[i][1])\n        return false;\n      return {\n        message: \"Expected \" + typeofChecks[i][1] + \", got \" + stringForErrorMessage(value, { onlyShowType: true }),\n        path: \"\"\n      };\n    }\n  }\n\n  if (pattern === null) {\n    if (value === null) {\n      return false;\n    }\n    return {\n      message: \"Expected null, got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  }\n\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\n  if (typeof pattern === \"string\" || typeof pattern === \"number\" || typeof pattern === \"boolean\") {\n    if (value === pattern)\n      return false;\n    return {\n      message: \"Expected \" + pattern + \", got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  }\n\n  // Match.Integer is special type encoded with array\n  if (pattern === Match.Integer) {\n    // There is no consistent and reliable way to check if variable is a 64-bit\n    // integer. One of the popular solutions is to get reminder of division by 1\n    // but this method fails on really large floats with big precision.\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\n    // Bitwise operators work consistantly but always cast variable to 32-bit\n    // signed integer according to JavaScript specs.\n    if (typeof value === \"number\" && (value | 0) === value)\n      return false;\n    return {\n      message: \"Expected Integer, got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  }\n\n  // \"Object\" is shorthand for Match.ObjectIncluding({});\n  if (pattern === Object)\n    pattern = Match.ObjectIncluding({});\n\n  // Array (checked AFTER Any, which is implemented as an Array).\n  if (pattern instanceof Array) {\n    if (pattern.length !== 1) {\n      return {\n        message: \"Bad pattern: arrays must have one type element\" + stringForErrorMessage(pattern),\n        path: \"\"\n      };\n    }\n    if (!Array.isArray(value) && !isArguments(value)) {\n      return {\n        message: \"Expected array, got \" + stringForErrorMessage(value),\n        path: \"\"\n      };\n    }\n\n    for (var i = 0, length = value.length; i < length; i++) {\n      var result = testSubtree(value[i], pattern[0]);\n      if (result) {\n        result.path = _prependPath(i, result.path);\n        return result;\n      }\n    }\n    return false;\n  }\n\n  // Arbitrary validation checks. The condition can return false or throw a\n  // Match.Error (ie, it can internally use check()) to fail.\n  if (pattern instanceof Where) {\n    var result;\n    try {\n      result = pattern.condition(value);\n    } catch (err) {\n      if (!(err instanceof Match.Error))\n        throw err;\n      return {\n        message: err.message,\n        path: err.path\n      };\n    }\n    if (result)\n      return false;\n    // XXX this error is terrible\n    return {\n      message: \"Failed Match.Where validation\",\n      path: \"\"\n    };\n  }\n\n\n  if (pattern instanceof Maybe) {\n    pattern = Match.OneOf(undefined, null, pattern.pattern);\n  }\n  else if (pattern instanceof Optional) {\n    pattern = Match.OneOf(undefined, pattern.pattern);\n  }\n\n  if (pattern instanceof OneOf) {\n    for (var i = 0; i < pattern.choices.length; ++i) {\n      var result = testSubtree(value, pattern.choices[i]);\n      if (!result) {\n        // No error? Yay, return.\n        return false;\n      }\n      // Match errors just mean try another choice.\n    }\n    // XXX this error is terrible\n    return {\n      message: \"Failed Match.OneOf, Match.Maybe or Match.Optional validation\",\n      path: \"\"\n    };\n  }\n\n  // A function that isn't something we special-case is assumed to be a\n  // constructor.\n  if (pattern instanceof Function) {\n    if (value instanceof pattern)\n      return false;\n    return {\n      message: \"Expected \" + (pattern.name ||\"particular constructor\"),\n      path: \"\"\n    };\n  }\n\n  var unknownKeysAllowed = false;\n  var unknownKeyPattern;\n  if (pattern instanceof ObjectIncluding) {\n    unknownKeysAllowed = true;\n    pattern = pattern.pattern;\n  }\n  if (pattern instanceof ObjectWithValues) {\n    unknownKeysAllowed = true;\n    unknownKeyPattern = [pattern.pattern];\n    pattern = {};  // no required keys\n  }\n\n  if (typeof pattern !== \"object\") {\n    return {\n      message: \"Bad pattern: unknown pattern type\",\n      path: \"\"\n    };\n  }\n\n  // An object, with required and optional keys. Note that this does NOT do\n  // structural matches against objects of special types that happen to match\n  // the pattern: this really needs to be a plain old {Object}!\n  if (typeof value !== 'object') {\n    return {\n      message: \"Expected object, got \" + typeof value,\n      path: \"\"\n    };\n  }\n  if (value === null) {\n    return {\n      message: \"Expected object, got null\",\n      path: \"\"\n    };\n  }\n  if (! isPlainObject(value)) {\n    return {\n      message: \"Expected plain object\",\n      path: \"\"\n    };\n  }\n\n  var requiredPatterns = {};\n  var optionalPatterns = {};\n\n  Object.keys(pattern).forEach(key => {\n    const subPattern = pattern[key];\n    if (subPattern instanceof Optional ||\n        subPattern instanceof Maybe) {\n      optionalPatterns[key] = subPattern.pattern;\n    } else {\n      requiredPatterns[key] = subPattern;\n    }\n  });\n\n  for (var key in Object(value)) {\n    var subValue = value[key];\n    if (hasOwn.call(requiredPatterns, key)) {\n      var result = testSubtree(subValue, requiredPatterns[key]);\n      if (result) {\n        result.path = _prependPath(key, result.path);\n        return result;\n      }\n      delete requiredPatterns[key];\n    } else if (hasOwn.call(optionalPatterns, key)) {\n      var result = testSubtree(subValue, optionalPatterns[key]);\n      if (result) {\n        result.path = _prependPath(key, result.path);\n        return result;\n      }\n    } else {\n      if (!unknownKeysAllowed) {\n        return {\n          message: \"Unknown key\",\n          path: key\n        };\n      }\n      if (unknownKeyPattern) {\n        var result = testSubtree(subValue, unknownKeyPattern[0]);\n        if (result) {\n          result.path = _prependPath(key, result.path);\n          return result;\n        }\n      }\n    }\n  }\n\n  var keys = Object.keys(requiredPatterns);\n  if (keys.length) {\n    return {\n      message: \"Missing key '\" + keys[0] + \"'\",\n      path: \"\"\n    };\n  }\n};\n\nclass ArgumentChecker {\n  constructor (args, description) {\n    // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\n    // against its contents.)\n    this.args = [...args];\n    // Since the common case will be to check arguments in order, and we splice\n    // out arguments when we check them, make it so we splice out from the end\n    // rather than the beginning.\n    this.args.reverse();\n    this.description = description;\n  }\n\n  checking(value) {\n    if (this._checkingOneValue(value))\n      return;\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\n    // or check([foo, bar], [String]) to count... but only if value wasn't\n    // itself an argument.\n    if (Array.isArray(value) || isArguments(value)) {\n      Array.prototype.forEach.call(value, this._checkingOneValue.bind(this));\n    }\n  }\n\n  _checkingOneValue(value) {\n    for (var i = 0; i < this.args.length; ++i) {\n      // Is this value one of the arguments? (This can have a false positive if\n      // the argument is an interned primitive, but it's still a good enough\n      // check.)\n      // (NaN is not === to itself, so we have to check specially.)\n      if (value === this.args[i] ||\n          (Number.isNaN(value) && Number.isNaN(this.args[i]))) {\n        this.args.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  throwUnlessAllArgumentsHaveBeenChecked() {\n    if (this.args.length > 0)\n      throw new Error(\"Did not check() all arguments during \" +\n                      this.description);\n  }\n}\n\nvar _jsKeywords = [\"do\", \"if\", \"in\", \"for\", \"let\", \"new\", \"try\", \"var\", \"case\",\n  \"else\", \"enum\", \"eval\", \"false\", \"null\", \"this\", \"true\", \"void\", \"with\",\n  \"break\", \"catch\", \"class\", \"const\", \"super\", \"throw\", \"while\", \"yield\",\n  \"delete\", \"export\", \"import\", \"public\", \"return\", \"static\", \"switch\",\n  \"typeof\", \"default\", \"extends\", \"finally\", \"package\", \"private\", \"continue\",\n  \"debugger\", \"function\", \"arguments\", \"interface\", \"protected\", \"implements\",\n  \"instanceof\"];\n\n// Assumes the base of path is already escaped properly\n// returns key + base\nfunction _prependPath(key, base) {\n  if ((typeof key) === \"number\" || key.match(/^[0-9]+$/)) {\n    key = \"[\" + key + \"]\";\n  } else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) ||\n             _jsKeywords.indexOf(key) >= 0) {\n    key = JSON.stringify([key]);\n  }\n\n  if (base && base[0] !== \"[\") {\n    return key + '.' + base;\n  }\n\n  return key + base;\n}\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n\nfunction baseIsArguments(item) {\n  return isObject(item) &&\n    Object.prototype.toString.call(item) === '[object Arguments]';\n}\n\nvar isArguments = baseIsArguments(function() {\n  return arguments;\n}()) ? baseIsArguments : function(value) {\n  return isObject(value) && typeof value.callee === \"function\";\n};\n","// Copy of jQuery.isPlainObject for the server side from jQuery v3.1.1.\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call(Object);\n\nvar getProto = Object.getPrototypeOf;\n\nexports.isPlainObject = function( obj ) {\n  var proto,\n    Ctor;\n\n  // Detect obvious negatives\n  // Use toString instead of jQuery.type to catch host objects\n  if (!obj || toString.call(obj) !== \"[object Object]\") {\n    return false;\n  }\n\n  proto = getProto(obj);\n\n  // Objects with no prototype (e.g., `Object.create( null )`) are plain\n  if (!proto) {\n    return true;\n  }\n\n  // Objects with prototype are plain iff they were constructed by a global Object function\n  Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n};\n"]}}]